Help on class Literal in module rdflib.term:

class LLiitteerraall(Identifier)
 |  Literal(lexical_or_value: Any, lang: Optional[str] = None, datatype: Optional[str] = None, normalize: Optional[bool] = None) -> 'Literal'
 |  
 |  RDF 1.1's Literals Section: http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal
 |  
 |  Literals are used for values such as strings, numbers, and dates.
 |  
 |  A literal in an RDF graph consists of two or three elements:
 |  
 |  * a lexical form, being a Unicode string, which SHOULD be in Normal Form C
 |  * a datatype IRI, being an IRI identifying a datatype that determines how the lexical form maps to a literal value, and
 |  * if and only if the datatype IRI is ``http://www.w3.org/1999/02/22-rdf-syntax-ns#langString``, a non-empty language tag. The language tag MUST be well-formed according to section 2.2.9 of `Tags for identifying languages <http://tools.ietf.org/html/bcp47>`_.
 |  
 |  A literal is a language-tagged string if the third element is present. Lexical representations of language tags MAY be converted to lower case. The value space of language tags is always in lower case.
 |  
 |  ---
 |  
 |  For valid XSD datatypes, the lexical form is optionally normalized
 |  at construction time. Default behaviour is set by rdflib.NORMALIZE_LITERALS
 |  and can be overridden by the normalize parameter to __new__
 |  
 |  Equality and hashing of Literals are done based on the lexical form, i.e.:
 |  
 |  >>> from rdflib.namespace import XSD
 |  
 |  >>> Literal('01') != Literal('1')  # clear - strings differ
 |  True
 |  
 |  but with data-type they get normalized:
 |  
 |  >>> Literal('01', datatype=XSD.integer) != Literal('1', datatype=XSD.integer)
 |  False
 |  
 |  unless disabled:
 |  
 |  >>> Literal('01', datatype=XSD.integer, normalize=False) != Literal('1', datatype=XSD.integer)
 |  True
 |  
 |  
 |  Value based comparison is possible:
 |  
 |  >>> Literal('01', datatype=XSD.integer).eq(Literal('1', datatype=XSD.float))
 |  True
 |  
 |  The eq method also provides limited support for basic python types:
 |  
 |  >>> Literal(1).eq(1) # fine - int compatible with xsd:integer
 |  True
 |  >>> Literal('a').eq('b') # fine - str compatible with plain-lit
 |  False
 |  >>> Literal('a', datatype=XSD.string).eq('a') # fine - str compatible with xsd:string
 |  True
 |  >>> Literal('a').eq(1) # not fine, int incompatible with plain-lit
 |  NotImplemented
 |  
 |  Greater-than/less-than ordering comparisons are also done in value
 |  space, when compatible datatypes are used.  Incompatible datatypes
 |  are ordered by DT, or by lang-tag.  For other nodes the ordering
 |  is None < BNode < URIRef < Literal
 |  
 |  Any comparison with non-rdflib Node are "NotImplemented"
 |  In PY3 this is an error.
 |  
 |  >>> from rdflib import Literal, XSD
 |  >>> lit2006 = Literal('2006-01-01',datatype=XSD.date)
 |  >>> lit2006.toPython()
 |  datetime.date(2006, 1, 1)
 |  >>> lit2006 < Literal('2007-01-01',datatype=XSD.date)
 |  True
 |  >>> Literal(datetime.utcnow()).datatype
 |  rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#dateTime')
 |  >>> Literal(1) > Literal(2) # by value
 |  False
 |  >>> Literal(1) > Literal(2.0) # by value
 |  False
 |  >>> Literal('1') > Literal(1) # by DT
 |  True
 |  >>> Literal('1') < Literal('1') # by lexical form
 |  False
 |  >>> Literal('a', lang='en') > Literal('a', lang='fr') # by lang-tag
 |  False
 |  >>> Literal(1) > URIRef('foo') # by node-type
 |  True
 |  
 |  The > < operators will eat this NotImplemented and throw a TypeError (py3k):
 |  
 |  >>> Literal(1).__gt__(2.0)
 |  NotImplemented
 |  
 |  Method resolution order:
 |      Literal
 |      Identifier
 |      Node
 |      builtins.str
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  ____aabbss____(self) -> 'Literal'
 |      >>> abs(Literal(-1))
 |      rdflib.term.Literal('1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      >>> from rdflib.namespace import XSD
 |      >>> abs( Literal("-1", datatype=XSD.integer))
 |      rdflib.term.Literal('1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      >>> abs(Literal("1"))
 |      Traceback (most recent call last):
 |        File "<stdin>", line 1, in <module>
 |      TypeError: Not a number; rdflib.term.Literal('1')
 |  
 |  ____aadddd____(self, val: Any) -> 'Literal'
 |      >>> from rdflib.namespace import XSD
 |      >>> Literal(1) + 1
 |      rdflib.term.Literal('2', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      >>> Literal("1") + "1"
 |      rdflib.term.Literal('11')
 |      
 |      # Handling dateTime/date/time based operations in Literals
 |      >>> a = Literal('2006-01-01T20:50:00', datatype=XSD.dateTime)
 |      >>> b = Literal('P31D', datatype=XSD.duration)
 |      >>> (a + b)
 |      rdflib.term.Literal('2006-02-01T20:50:00', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#dateTime'))
 |      >>> from rdflib.namespace import XSD
 |      >>> a = Literal('2006-07-01T20:52:00', datatype=XSD.dateTime)
 |      >>> b = Literal('P122DT15H58M', datatype=XSD.duration)
 |      >>> (a + b)
 |      rdflib.term.Literal('2006-11-01T12:50:00', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#dateTime'))
 |  
 |  ____bbooooll____(self) -> bool
 |      Is the Literal "True"
 |      This is used for if statements, bool(literal), etc.
 |  
 |  ____eeqq____(self, other: Any) -> bool
 |      Literals are only equal to other literals.
 |      
 |      "Two literals are equal if and only if all of the following hold:
 |      * The strings of the two lexical forms compare equal, character by character.
 |      * Either both or neither have language tags.
 |      * The language tags, if any, compare equal.
 |      * Either both or neither have datatype URIs.
 |      * The two datatype URIs, if any, compare equal, character by character."
 |      -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)
 |      
 |      >>> Literal("1", datatype=URIRef("foo")) == Literal("1", datatype=URIRef("foo"))
 |      True
 |      >>> Literal("1", datatype=URIRef("foo")) == Literal("1", datatype=URIRef("foo2"))
 |      False
 |      
 |      >>> Literal("1", datatype=URIRef("foo")) == Literal("2", datatype=URIRef("foo"))
 |      False
 |      >>> Literal("1", datatype=URIRef("foo")) == "asdf"
 |      False
 |      >>> from rdflib import XSD
 |      >>> Literal('2007-01-01', datatype=XSD.date) == Literal('2007-01-01', datatype=XSD.date)
 |      True
 |      >>> Literal('2007-01-01', datatype=XSD.date) == date(2007, 1, 1)
 |      False
 |      >>> Literal("one", lang="en") == Literal("one", lang="en")
 |      True
 |      >>> Literal("hast", lang='en') == Literal("hast", lang='de')
 |      False
 |      >>> Literal("1", datatype=XSD.integer) == Literal(1)
 |      True
 |      >>> Literal("1", datatype=XSD.integer) == Literal("01", datatype=XSD.integer)
 |      True
 |  
 |  ____ggee____(self, other: Any) -> bool
 |      Return self>=value.
 |  
 |  ____ggeettssttaattee____(self) -> Tuple[NoneType, Dict[str, Optional[str]]]
 |  
 |  ____ggtt____(self, other: Any) -> bool
 |      This implements ordering for Literals,
 |      the other comparison methods delegate here
 |      
 |      This tries to implement this:
 |      http://www.w3.org/TR/sparql11-query/#modOrderBy
 |      
 |      In short, Literals with compatible data-types are ordered in value
 |      space, i.e.
 |      >>> from rdflib import XSD
 |      
 |      >>> Literal(1) > Literal(2) # int/int
 |      False
 |      >>> Literal(2.0) > Literal(1) # double/int
 |      True
 |      >>> from decimal import Decimal
 |      >>> Literal(Decimal("3.3")) > Literal(2.0) # decimal/double
 |      True
 |      >>> Literal(Decimal("3.3")) < Literal(4.0) # decimal/double
 |      True
 |      >>> Literal('b') > Literal('a') # plain lit/plain lit
 |      True
 |      >>> Literal('b') > Literal('a', datatype=XSD.string) # plain lit/xsd:str
 |      True
 |      
 |      Incompatible datatype mismatches ordered by DT
 |      
 |      >>> Literal(1) > Literal("2") # int>string
 |      False
 |      
 |      Langtagged literals by lang tag
 |      >>> Literal("a", lang="en") > Literal("a", lang="fr")
 |      False
 |  
 |  ____hhaasshh____(self) -> int
 |      >>> from rdflib.namespace import XSD
 |      >>> a = {Literal('1', datatype=XSD.integer):'one'}
 |      >>> Literal('1', datatype=XSD.double) in a
 |      False
 |      
 |      
 |      "Called for the key object for dictionary operations,
 |      and by the built-in function hash(). Should return
 |      a 32-bit integer usable as a hash value for
 |      dictionary operations. The only required property
 |      is that objects which compare equal have the same
 |      hash value; it is advised to somehow mix together
 |      (e.g., using exclusive or) the hash values for the
 |      components of the object that also play a part in
 |      comparison of objects." -- 3.4.1 Basic customization (Python)
 |      
 |      "Two literals are equal if and only if all of the following hold:
 |      * The strings of the two lexical forms compare equal, character by
 |      character.
 |      * Either both or neither have language tags.
 |      * The language tags, if any, compare equal.
 |      * Either both or neither have datatype URIs.
 |      * The two datatype URIs, if any, compare equal, character by
 |      character."
 |      -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)
 |  
 |  ____iinnvveerrtt____(self) -> 'Literal'
 |      >>> ~(Literal(-1))
 |      rdflib.term.Literal('0', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      >>> from rdflib.namespace import XSD
 |      >>> ~( Literal("-1", datatype=XSD.integer))
 |      rdflib.term.Literal('0', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      Not working:
 |      
 |      >>> ~(Literal("1"))
 |      Traceback (most recent call last):
 |        File "<stdin>", line 1, in <module>
 |      TypeError: Not a number; rdflib.term.Literal('1')
 |  
 |  ____llee____(self, other: Any) -> bool
 |      >>> from rdflib.namespace import XSD
 |      >>> Literal('2007-01-01T10:00:00', datatype=XSD.dateTime
 |      ...     ) <= Literal('2007-01-01T10:00:00', datatype=XSD.dateTime)
 |      True
 |  
 |  ____lltt____(self, other: Any) -> bool
 |      Return self<value.
 |  
 |  ____nneegg____(self) -> 'Literal'
 |      >>> (- Literal(1))
 |      rdflib.term.Literal('-1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      >>> (- Literal(10.5))
 |      rdflib.term.Literal('-10.5', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#double'))
 |      >>> from rdflib.namespace import XSD
 |      >>> (- Literal("1", datatype=XSD.integer))
 |      rdflib.term.Literal('-1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      >>> (- Literal("1"))
 |      Traceback (most recent call last):
 |        File "<stdin>", line 1, in <module>
 |      TypeError: Not a number; rdflib.term.Literal('1')
 |      >>>
 |  
 |  ____ppooss____(self) -> 'Literal'
 |      >>> (+ Literal(1))
 |      rdflib.term.Literal('1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      >>> (+ Literal(-1))
 |      rdflib.term.Literal('-1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      >>> from rdflib.namespace import XSD
 |      >>> (+ Literal("-1", datatype=XSD.integer))
 |      rdflib.term.Literal('-1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      >>> (+ Literal("1"))
 |      Traceback (most recent call last):
 |        File "<stdin>", line 1, in <module>
 |      TypeError: Not a number; rdflib.term.Literal('1')
 |  
 |  ____rreedduuccee____(self) -> Tuple[Type[ForwardRef('Literal')], Tuple[str, Optional[str], Optional[str]]]
 |      Helper for pickle.
 |  
 |  ____rreepprr____(self) -> str
 |      Return repr(self).
 |  
 |  ____sseettssttaattee____(self, arg: Tuple[Any, Dict[str, Any]]) -> None
 |  
 |  ____ssuubb____(self, val: Any) -> 'Literal'
 |      >>> from rdflib.namespace import XSD
 |      >>> Literal(2) - 1
 |      rdflib.term.Literal('1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      >>> Literal(1.1) - 1.0
 |      rdflib.term.Literal('0.10000000000000009', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#double'))
 |      >>> Literal(1.1) - 1
 |      rdflib.term.Literal('0.1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#decimal'))
 |      >>> Literal(1.1, datatype=XSD.float) - Literal(1.0, datatype=XSD.float)
 |      rdflib.term.Literal('0.10000000000000009', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#float'))
 |      >>> Literal("1.1") - 1.0 # doctest: +IGNORE_EXCEPTION_DETAIL
 |      Traceback (most recent call last):
 |      ...
 |      TypeError: Not a number; rdflib.term.Literal('1.1')
 |      >>> Literal(1.1, datatype=XSD.integer) - Literal(1.0, datatype=XSD.integer)
 |      rdflib.term.Literal('0.10000000000000009', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      # Handling dateTime/date/time based operations in Literals
 |      >>> a = Literal('2006-01-01T20:50:00', datatype=XSD.dateTime)
 |      >>> b = Literal('2006-02-01T20:50:00', datatype=XSD.dateTime)
 |      >>> (b - a)
 |      rdflib.term.Literal('P31D', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#duration'))
 |      >>> from rdflib.namespace import XSD
 |      >>> a = Literal('2006-07-01T20:52:00', datatype=XSD.dateTime)
 |      >>> b = Literal('2006-11-01T12:50:00', datatype=XSD.dateTime)
 |      >>> (a - b)
 |      rdflib.term.Literal('-P122DT15H58M', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#duration'))
 |      >>> (b - a)
 |      rdflib.term.Literal('P122DT15H58M', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#duration'))
 |  
 |  eeqq(self, other: Any) -> bool
 |      Compare the value of this literal with something else
 |      
 |      Either, with the value of another literal
 |      comparisons are then done in literal "value space",
 |      and according to the rules of XSD subtype-substitution/type-promotion
 |      
 |      OR, with a python object:
 |      
 |      basestring objects can be compared with plain-literals,
 |      or those with datatype xsd:string
 |      
 |      bool objects with xsd:boolean
 |      
 |      a int, long or float with numeric xsd types
 |      
 |      isodate date,time,datetime objects with xsd:date,xsd:time or xsd:datetime
 |      
 |      Any other operations returns NotImplemented
 |  
 |  nn33(self, namespace_manager: Optional[ForwardRef('NamespaceManager')] = None) -> str
 |      Returns a representation in the N3 format.
 |      
 |      Examples::
 |      
 |          >>> Literal("foo").n3()
 |          '"foo"'
 |      
 |      Strings with newlines or triple-quotes::
 |      
 |          >>> Literal("foo\nbar").n3()
 |          '"""foo\nbar"""'
 |      
 |          >>> Literal("''\'").n3()
 |          '"\'\'\'"'
 |      
 |          >>> Literal('"""').n3()
 |          '"\\"\\"\\""'
 |      
 |      Language::
 |      
 |          >>> Literal("hello", lang="en").n3()
 |          '"hello"@en'
 |      
 |      Datatypes::
 |      
 |          >>> Literal(1).n3()
 |          '"1"^^<http://www.w3.org/2001/XMLSchema#integer>'
 |      
 |          >>> Literal(1.0).n3()
 |          '"1.0"^^<http://www.w3.org/2001/XMLSchema#double>'
 |      
 |          >>> Literal(True).n3()
 |          '"true"^^<http://www.w3.org/2001/XMLSchema#boolean>'
 |      
 |      Datatype and language isn't allowed (datatype takes precedence)::
 |      
 |          >>> Literal(1, lang="en").n3()
 |          '"1"^^<http://www.w3.org/2001/XMLSchema#integer>'
 |      
 |      Custom datatype::
 |      
 |          >>> footype = URIRef("http://example.org/ns#foo")
 |          >>> Literal("1", datatype=footype).n3()
 |          '"1"^^<http://example.org/ns#foo>'
 |      
 |      Passing a namespace-manager will use it to abbreviate datatype URIs:
 |      
 |          >>> from rdflib import Graph
 |          >>> Literal(1).n3(Graph().namespace_manager)
 |          '"1"^^xsd:integer'
 |  
 |  nneeqq(self, other: Any) -> bool
 |      A "semantic"/interpreted not equal function,
 |      by default, same as __ne__
 |  
 |  nnoorrmmaalliizzee(self) -> 'Literal'
 |      Returns a new literal with a normalised lexical representation
 |      of this literal
 |      >>> from rdflib import XSD
 |      >>> Literal("01", datatype=XSD.integer, normalize=False).normalize()
 |      rdflib.term.Literal('1', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |      
 |      Illegal lexical forms for the datatype given are simply passed on
 |      >>> Literal("a", datatype=XSD.integer, normalize=False)
 |      rdflib.term.Literal('a', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer'))
 |  
 |  ttooPPyytthhoonn(self) -> Any
 |      Returns an appropriate python datatype derived from this RDF Literal
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  ____nneeww____(cls, lexical_or_value: Any, lang: Optional[str] = None, datatype: Optional[str] = None, normalize: Optional[bool] = None) -> 'Literal'
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |  
 |  ddaattaattyyppee
 |  
 |  iillll__ttyyppeedd
 |      For `recognized datatype IRIs
 |      <https://www.w3.org/TR/rdf11-concepts/#dfn-recognized-datatype-iris>`_,
 |      this value will be `True` if the literal is ill formed, otherwise it
 |      will be `False`. `Literal.value` (i.e. the `literal value <https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value>`_) should always be defined if this property is `False`, but should not be considered reliable if this property is `True`.
 |      
 |      If the literal's datatype is `None` or not in the set of `recognized datatype IRIs
 |      <https://www.w3.org/TR/rdf11-concepts/#dfn-recognized-datatype-iris>`_ this value will be `None`.
 |  
 |  llaanngguuaaggee
 |  
 |  vvaalluuee
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ____aannnnoottaattiioonnss____ = {'_datatype': typing.Optional[rdflib.term.URIRef], '...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from Identifier:
 |  
 |  ____nnee____(self, other: Any) -> bool
 |      Return self!=value.
 |  
 |  ssttaarrttsswwiitthh(self, prefix: str, start=Ellipsis, end=Ellipsis) -> bool
 |      S.startswith(prefix[, start[, end]]) -> bool
 |      
 |      Return True if S starts with the specified prefix, False otherwise.
 |      With optional start, test S beginning at that position.
 |      With optional end, stop comparing S at that position.
 |      prefix can also be a tuple of strings to try.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.str:
 |  
 |  ____ccoonnttaaiinnss____(self, key, /)
 |      Return key in self.
 |  
 |  ____ffoorrmmaatt____(self, format_spec, /)
 |      Return a formatted version of the string as described by format_spec.
 |  
 |  ____ggeettaattttrriibbuuttee____(self, name, /)
 |      Return getattr(self, name).
 |  
 |  ____ggeettiitteemm____(self, key, /)
 |      Return self[key].
 |  
 |  ____ggeettnneewwaarrggss____(...)
 |  
 |  ____iitteerr____(self, /)
 |      Implement iter(self).
 |  
 |  ____lleenn____(self, /)
 |      Return len(self).
 |  
 |  ____mmoodd____(self, value, /)
 |      Return self%value.
 |  
 |  ____mmuull____(self, value, /)
 |      Return self*value.
 |  
 |  ____rrmmoodd____(self, value, /)
 |      Return value%self.
 |  
 |  ____rrmmuull____(self, value, /)
 |      Return value*self.
 |  
 |  ____ssiizzeeooff____(self, /)
 |      Return the size of the string in memory, in bytes.
 |  
 |  ____ssttrr____(self, /)
 |      Return str(self).
 |  
 |  ccaappiittaalliizzee(self, /)
 |      Return a capitalized version of the string.
 |      
 |      More specifically, make the first character have upper case and the rest lower
 |      case.
 |  
 |  ccaasseeffoolldd(self, /)
 |      Return a version of the string suitable for caseless comparisons.
 |  
 |  cceenntteerr(self, width, fillchar=' ', /)
 |      Return a centered string of length width.
 |      
 |      Padding is done using the specified fill character (default is a space).
 |  
 |  ccoouunntt(...)
 |      S.count(sub[, start[, end]]) -> int
 |      
 |      Return the number of non-overlapping occurrences of substring sub in
 |      string S[start:end].  Optional arguments start and end are
 |      interpreted as in slice notation.
 |  
 |  eennccooddee(self, /, encoding='utf-8', errors='strict')
 |      Encode the string using the codec registered for encoding.
 |      
 |      encoding
 |        The encoding in which to encode the string.
 |      errors
 |        The error handling scheme to use for encoding errors.
 |        The default is 'strict' meaning that encoding errors raise a
 |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
 |        'xmlcharrefreplace' as well as any other name registered with
 |        codecs.register_error that can handle UnicodeEncodeErrors.
 |  
 |  eennddsswwiitthh(...)
 |      S.endswith(suffix[, start[, end]]) -> bool
 |      
 |      Return True if S ends with the specified suffix, False otherwise.
 |      With optional start, test S beginning at that position.
 |      With optional end, stop comparing S at that position.
 |      suffix can also be a tuple of strings to try.
 |  
 |  eexxppaannddttaabbss(self, /, tabsize=8)
 |      Return a copy where all tab characters are expanded using spaces.
 |      
 |      If tabsize is not given, a tab size of 8 characters is assumed.
 |  
 |  ffiinndd(...)
 |      S.find(sub[, start[, end]]) -> int
 |      
 |      Return the lowest index in S where substring sub is found,
 |      such that sub is contained within S[start:end].  Optional
 |      arguments start and end are interpreted as in slice notation.
 |      
 |      Return -1 on failure.
 |  
 |  ffoorrmmaatt(...)
 |      S.format(*args, **kwargs) -> str
 |      
 |      Return a formatted version of S, using substitutions from args and kwargs.
 |      The substitutions are identified by braces ('{' and '}').
 |  
 |  ffoorrmmaatt__mmaapp(...)
 |      S.format_map(mapping) -> str
 |      
 |      Return a formatted version of S, using substitutions from mapping.
 |      The substitutions are identified by braces ('{' and '}').
 |  
 |  iinnddeexx(...)
 |      S.index(sub[, start[, end]]) -> int
 |      
 |      Return the lowest index in S where substring sub is found,
 |      such that sub is contained within S[start:end].  Optional
 |      arguments start and end are interpreted as in slice notation.
 |      
 |      Raises ValueError when the substring is not found.
 |  
 |  iissaallnnuumm(self, /)
 |      Return True if the string is an alpha-numeric string, False otherwise.
 |      
 |      A string is alpha-numeric if all characters in the string are alpha-numeric and
 |      there is at least one character in the string.
 |  
 |  iissaallpphhaa(self, /)
 |      Return True if the string is an alphabetic string, False otherwise.
 |      
 |      A string is alphabetic if all characters in the string are alphabetic and there
 |      is at least one character in the string.
 |  
 |  iissaasscciiii(self, /)
 |      Return True if all characters in the string are ASCII, False otherwise.
 |      
 |      ASCII characters have code points in the range U+0000-U+007F.
 |      Empty string is ASCII too.
 |  
 |  iissddeecciimmaall(self, /)
 |      Return True if the string is a decimal string, False otherwise.
 |      
 |      A string is a decimal string if all characters in the string are decimal and
 |      there is at least one character in the string.
 |  
 |  iissddiiggiitt(self, /)
 |      Return True if the string is a digit string, False otherwise.
 |      
 |      A string is a digit string if all characters in the string are digits and there
 |      is at least one character in the string.
 |  
 |  iissiiddeennttiiffiieerr(self, /)
 |      Return True if the string is a valid Python identifier, False otherwise.
 |      
 |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
 |      such as "def" or "class".
 |  
 |  iisslloowweerr(self, /)
 |      Return True if the string is a lowercase string, False otherwise.
 |      
 |      A string is lowercase if all cased characters in the string are lowercase and
 |      there is at least one cased character in the string.
 |  
 |  iissnnuummeerriicc(self, /)
 |      Return True if the string is a numeric string, False otherwise.
 |      
 |      A string is numeric if all characters in the string are numeric and there is at
 |      least one character in the string.
 |  
 |  iisspprriinnttaabbllee(self, /)
 |      Return True if the string is printable, False otherwise.
 |      
 |      A string is printable if all of its characters are considered printable in
 |      repr() or if it is empty.
 |  
 |  iissssppaaccee(self, /)
 |      Return True if the string is a whitespace string, False otherwise.
 |      
 |      A string is whitespace if all characters in the string are whitespace and there
 |      is at least one character in the string.
 |  
 |  iissttiittllee(self, /)
 |      Return True if the string is a title-cased string, False otherwise.
 |      
 |      In a title-cased string, upper- and title-case characters may only
 |      follow uncased characters and lowercase characters only cased ones.
 |  
 |  iissuuppppeerr(self, /)
 |      Return True if the string is an uppercase string, False otherwise.
 |      
 |      A string is uppercase if all cased characters in the string are uppercase and
 |      there is at least one cased character in the string.
 |  
 |  jjooiinn(self, iterable, /)
 |      Concatenate any number of strings.
 |      
 |      The string whose method is called is inserted in between each given string.
 |      The result is returned as a new string.
 |      
 |      Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
 |  
 |  lljjuusstt(self, width, fillchar=' ', /)
 |      Return a left-justified string of length width.
 |      
 |      Padding is done using the specified fill character (default is a space).
 |  
 |  lloowweerr(self, /)
 |      Return a copy of the string converted to lowercase.
 |  
 |  llssttrriipp(self, chars=None, /)
 |      Return a copy of the string with leading whitespace removed.
 |      
 |      If chars is given and not None, remove characters in chars instead.
 |  
 |  ppaarrttiittiioonn(self, sep, /)
 |      Partition the string into three parts using the given separator.
 |      
 |      This will search for the separator in the string.  If the separator is found,
 |      returns a 3-tuple containing the part before the separator, the separator
 |      itself, and the part after it.
 |      
 |      If the separator is not found, returns a 3-tuple containing the original string
 |      and two empty strings.
 |  
 |  rreemmoovveepprreeffiixx(self, prefix, /)
 |      Return a str with the given prefix string removed if present.
 |      
 |      If the string starts with the prefix string, return string[len(prefix):].
 |      Otherwise, return a copy of the original string.
 |  
 |  rreemmoovveessuuffffiixx(self, suffix, /)
 |      Return a str with the given suffix string removed if present.
 |      
 |      If the string ends with the suffix string and that suffix is not empty,
 |      return string[:-len(suffix)]. Otherwise, return a copy of the original
 |      string.
 |  
 |  rreeppllaaccee(self, old, new, count=-1, /)
 |      Return a copy with all occurrences of substring old replaced by new.
 |      
 |        count
 |          Maximum number of occurrences to replace.
 |          -1 (the default value) means replace all occurrences.
 |      
 |      If the optional argument count is given, only the first count occurrences are
 |      replaced.
 |  
 |  rrffiinndd(...)
 |      S.rfind(sub[, start[, end]]) -> int
 |      
 |      Return the highest index in S where substring sub is found,
 |      such that sub is contained within S[start:end].  Optional
 |      arguments start and end are interpreted as in slice notation.
 |      
 |      Return -1 on failure.
 |  
 |  rriinnddeexx(...)
 |      S.rindex(sub[, start[, end]]) -> int
 |      
 |      Return the highest index in S where substring sub is found,
 |      such that sub is contained within S[start:end].  Optional
 |      arguments start and end are interpreted as in slice notation.
 |      
 |      Raises ValueError when the substring is not found.
 |  
 |  rrjjuusstt(self, width, fillchar=' ', /)
 |      Return a right-justified string of length width.
 |      
 |      Padding is done using the specified fill character (default is a space).
 |  
 |  rrppaarrttiittiioonn(self, sep, /)
 |      Partition the string into three parts using the given separator.
 |      
 |      This will search for the separator in the string, starting at the end. If
 |      the separator is found, returns a 3-tuple containing the part before the
 |      separator, the separator itself, and the part after it.
 |      
 |      If the separator is not found, returns a 3-tuple containing two empty strings
 |      and the original string.
 |  
 |  rrsspplliitt(self, /, sep=None, maxsplit=-1)
 |      Return a list of the substrings in the string, using sep as the separator string.
 |      
 |        sep
 |          The separator used to split the string.
 |      
 |          When set to None (the default value), will split on any whitespace
 |          character (including \\n \\r \\t \\f and spaces) and will discard
 |          empty strings from the result.
 |        maxsplit
 |          Maximum number of splits (starting from the left).
 |          -1 (the default value) means no limit.
 |      
 |      Splitting starts at the end of the string and works to the front.
 |  
 |  rrssttrriipp(self, chars=None, /)
 |      Return a copy of the string with trailing whitespace removed.
 |      
 |      If chars is given and not None, remove characters in chars instead.
 |  
 |  sspplliitt(self, /, sep=None, maxsplit=-1)
 |      Return a list of the substrings in the string, using sep as the separator string.
 |      
 |        sep
 |          The separator used to split the string.
 |      
 |          When set to None (the default value), will split on any whitespace
 |          character (including \\n \\r \\t \\f and spaces) and will discard
 |          empty strings from the result.
 |        maxsplit
 |          Maximum number of splits (starting from the left).
 |          -1 (the default value) means no limit.
 |      
 |      Note, str.split() is mainly useful for data that has been intentionally
 |      delimited.  With natural text that includes punctuation, consider using
 |      the regular expression module.
 |  
 |  sspplliittlliinneess(self, /, keepends=False)
 |      Return a list of the lines in the string, breaking at line boundaries.
 |      
 |      Line breaks are not included in the resulting list unless keepends is given and
 |      true.
 |  
 |  ssttrriipp(self, chars=None, /)
 |      Return a copy of the string with leading and trailing whitespace removed.
 |      
 |      If chars is given and not None, remove characters in chars instead.
 |  
 |  sswwaappccaassee(self, /)
 |      Convert uppercase characters to lowercase and lowercase characters to uppercase.
 |  
 |  ttiittllee(self, /)
 |      Return a version of the string where each word is titlecased.
 |      
 |      More specifically, words start with uppercased characters and all remaining
 |      cased characters have lower case.
 |  
 |  ttrraannssllaattee(self, table, /)
 |      Replace each character in the string using the given translation table.
 |      
 |        table
 |          Translation table, which must be a mapping of Unicode ordinals to
 |          Unicode ordinals, strings, or None.
 |      
 |      The table must implement lookup/indexing via __getitem__, for instance a
 |      dictionary or list.  If this operation raises LookupError, the character is
 |      left untouched.  Characters mapped to None are deleted.
 |  
 |  uuppppeerr(self, /)
 |      Return a copy of the string converted to uppercase.
 |  
 |  zzffiillll(self, width, /)
 |      Pad a numeric string with zeros on the left, to fill a field of the given width.
 |      
 |      The string is never truncated.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from builtins.str:
 |  
 |  mmaakkeettrraannss(...)
 |      Return a translation table usable for str.translate().
 |      
 |      If there is only one argument, it must be a dictionary mapping Unicode
 |      ordinals (integers) or characters to Unicode ordinals, strings or None.
 |      Character keys will be then converted to ordinals.
 |      If there are two arguments, they must be strings of equal length, and
 |      in the resulting dictionary, each character in x will be mapped to the
 |      character at the same position in y. If there is a third argument, it
 |      must be a string, whose characters will be mapped to None in the result.
